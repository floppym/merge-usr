#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-or-later

import argparse
import contextlib
import errno
import fnmatch
import logging
import os
import os.path
import shutil
import stat
import sys
import tempfile

DIR_MAP = {
    "bin": "usr/bin",
    "sbin": "usr/bin",
    "usr/sbin": "usr/bin",
    "lib": "usr/lib",
    "lib32": "usr/lib32",
    "lib64": "usr/lib64",
    "libx32": "usr/libx32",
}

IGNORE_PATTERNS = (
    ".keep*",
)

args = None
logger = logging.getLogger(__name__)
errors = []

def ignore_name(name):
    return any((fnmatch.fnmatch(name, pattern) for pattern in IGNORE_PATTERNS))

def resolve_symlinks(path):
    try:
        target = os.readlink(path)
    except OSError:
        pass
    else:
        if os.path.isabs(target):
            path = os.path.join(args.root, os.path.relpath(target, "/"))
    return os.path.realpath(path)

def raise_exists(path):
    raise FileExistsError(errno.EEXIST, os.strerror(errno.EEXIST), path)

def check_object(src, dst, src_is_symlink):
    try:
        st = os.lstat(dst)
    except FileNotFoundError:
        return True
    if stat.S_ISLNK(st.st_mode):
        dst = resolve_symlinks(dst)
    if src_is_symlink:
        src = resolve_symlinks(src)
    if src != dst and not os.path.samefile(src, dst):
        raise_exists(dst)
    return not src_is_symlink

def copy_symlink(src, dst):
    if not check_object(src, dst, True):
        return
    if args.dryrun:
        return
    srcdir = os.path.dirname(src)
    dstdir = os.path.dirname(dst)
    target = os.readlink(src)
    if not os.path.isabs(target):
        t = os.path.join(srcdir, target)
        t = resolve_symlinks(t)
        if t.startswith(srcdir):
            target = os.path.relpath(t, srcdir)
        else:
            target = os.path.relpath(t, dstdir)
    os.symlink(target, dst)

def replace_with_symlink(src, dst):
    srcdir = os.path.dirname(src)
    target = os.path.relpath(dst, srcdir)
    tmp = tempfile.mktemp(dir=srcdir)
    os.symlink(target, tmp)
    os.rename(tmp, src)

def link_or_copy_file(src, dst):
    if not check_object(src, dst, False):
        return
    if args.dryrun:
        return
    tmp = tempfile.mktemp(dir=os.path.dirname(dst))
    try:
        os.link(src, tmp, follow_symlinks=False)
    except FileExistsError:
        raise
    except OSError:
        shutil.copy2(src, tmp)
    os.rename(tmp, dst)
    replace_with_symlink(src, dst)

def check_directory(path):
    if os.path.exists(path):
        if os.path.isdir(path):
            return True
        raise_exists(dst)
    return False

def ensure_directory(path):
    try:
        os.mkdir(path)
    except FileExistsError:
        if not os.path.isdir(path):
            raise
    else:
        os.chmod(path, 0o0755)

def log_error(filetype, path, error):
    errors.append((filetype, path, error))
    logger.error("Copying %s '%s': %s", filetype, path, error)

def copy_tree(srcdir, dstdir):
    with os.scandir(srcdir) as entries:
        for entry in entries:
            if ignore_name(entry.name):
                continue
            src = os.path.join(srcdir, entry.name)
            dst = os.path.join(dstdir, entry.name)
            if entry.is_symlink():
                try:
                    copy_symlink(src, dst)
                except Exception as e:
                    log_error("symlink", src, e)
            elif entry.is_file(follow_symlinks=False):
                try:
                    link_or_copy_file(src, dst)
                except Exception as e:
                    log_error("file", src, e)
            elif entry.is_dir(follow_symlinks=False):
                try:
                    ensure_directory(dst)
                    copy_tree(src, dst)
                except Exception as e:
                    log_error("directory", src, e)
            else:
                log_error("special", src, "Copying special files is not supported")


def merge_usr():
    for x in DIR_MAP:
        src = os.path.join(args.root, args.prefix, x)
        dst = os.path.join(args.root, args.prefix, DIR_MAP[x])

        if os.path.islink(src):
            logger.warning("Already a symlink: '%s'", src)
            continue

        if not os.path.exists(src):
            continue

        if not os.path.isdir(src):
            logger.warning("Not a directory: '%s'", src)
            continue

        copy_tree(src, dst)

        if not errors and not args.dryrun:
            target = os.path.relpath(dst, src)
            tmp = tempfile.mktemp(dir=os.path.dirname(src))
            os.rename(src, tmp)
            os.symlink(target, src)
            shutil.rmtree(tmp)

def main():
    logging.basicConfig()

    parser = argparse.ArgumentParser()
    parser.add_argument("--dryrun", action=argparse.BooleanOptionalAction)
    parser.add_argument("--root")
    parser.add_argument("--prefix")

    global args
    args = parser.parse_args()

    if args.root is None:
        args.root = "/"
    else:
        args.root = args.root.rstrip("/") + "/"

    if args.prefix is None:
        args.prefix = ""
    else:
        args.prefix = args.prefix.lstrip("/")

    os.umask(0o077)
    merge_usr()

if __name__ == "__main__":
    main()
